<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jersey Shore Surf Buddy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
            padding: 2rem;
            max-width: 700px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        select {
            border: 1px solid #cce7f0;
            border-radius: 0.75rem;
            padding: 0.9rem 1.25rem;
            width: 100%;
            margin-bottom: 1rem;
            font-size: 1.05rem;
        }
        button {
            background-color: #0ea5e9;
            color: white;
            padding: 0.9rem 1.8rem;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            font-size: 1.1rem;
            margin-top: 0.75rem;
            box-shadow: 0 4px 10px rgba(14, 165, 233, 0.3);
        }
        button:hover {
            background-color: #0284c7;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(14, 165, 233, 0.4);
        }
        #result-container {
            margin-top: 2rem;
            padding: 2rem;
            background-color: #f0faff;
            border-radius: 1rem;
            text-align: left;
            border: 1px solid #bfdbfe;
            box-shadow: inset 0 0 8px rgba(14, 165, 233, 0.05);
        }
        #loading-indicator {
            display: none;
            margin-top: 1.5rem;
            color: #0ea5e9;
            font-weight: 700;
            font-size: 1.1rem;
            animation: pulse 1.5s infinite ease-in-out;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        .forecast-visuals {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 1.5rem;
            align-items: center;
            margin-top: 1.5rem;
            padding: 1rem 0;
            border-top: 1px solid #e0e0e0;
        }
        .visual-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.9rem;
            color: #4a5568;
            font-weight: 600;
            text-align: center;
        }
        .visual-item svg { width: 32px; height: 32px; margin-bottom: 8px; }
        .wave-bar-container { width: 50px; height: 60px; background-color: #bfdbfe; border-radius: 0.25rem; overflow: hidden; display: flex; align-items: flex-end; margin-bottom: 8px; }
        .wave-bar { width: 100%; background-color: #3b82f6; transition: height 0.5s ease-out; }
        .wind-strength-bar-container { width: 60px; height: 10px; border-radius: 5px; background-color: #cbd5e0; overflow: hidden; margin-bottom: 8px; }
        .wind-strength-bar { height: 100%; background: linear-gradient(to right, #a7f3d0, #6ee7b7); transition: width 0.5s ease-out, background 0.5s ease-out; border-radius: 5px; }
        #windDirectionStatusText { font-size: 0.85rem; font-weight: 600; color: #2c3e50; margin-top: 4px; }
        .water-temp-indicator { width: 40px; height: 40px; border-radius: 50%; background-color: #ccc; margin-bottom: 8px; transition: background-color 0.5s ease-out; display: flex; justify-content: center; align-items: center; color: white; font-size: 0.8em; font-weight: bold; }
        .new-charts-section { margin-top: 2.5rem; padding-top: 1.5rem; border-top: 1px solid #e0e0e0; text-align: left; }
        .chart-canvas { background-color: #f7fafc; border: 1px solid #cce7f0; border-radius: 0.75rem; width: 100%; height: 150px; margin-top: 1rem; }
        #weatherChartCanvas, #windDirectionChartCanvas { background-color: transparent; border: none; }
        #current-tide-status, #next-tide-info { font-size: 0.95rem; font-weight: 600; color: #4a5568; margin-top: 0.75rem; text-align: center; }
        .surf-score-circle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #e0f2f7;
            border: 6px solid #ccc;
            transition: border-color 0.5s ease-in-out;
        }
        #surf-score-value {
            font-size: 1.75rem;
            font-weight: 800;
            color: #2c3e50;
        }
        #surf-score-label {
            font-size: 0.8rem;
            font-weight: 700;
            color: #4a5568;
            margin-top: -2px;
        }
        .sub-scores-container {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 1rem 0;
            border-top: 1px solid #e0e0e0;
        }
        .chart-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .chart-nav button {
            width: auto;
            padding: 0.25rem 0.75rem;
            font-size: 0.9rem;
            margin-top: 0;
        }
        #teaser-container {
            margin-bottom: 2rem;
            padding: 1rem;
            background-color: #000;
            border-radius: 1rem;
        }
        #feedback-container {
            margin-bottom: 2rem;
            padding: 1rem;
            background-color: #f0faff;
            border-radius: 1rem;
        }
        #feedback-container .star {
            cursor: pointer;
            transition: color 0.2s;
        }
        #feedback-container .star:hover,
        #feedback-container .star.selected {
            color: #f59e0b;
        }
        .chat-container {
            margin-top: 2.5rem;
            border-top: 1px solid #e0e0e0;
            padding-top: 2rem;
            text-align: left;
        }
        #chat-messages {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #cce7f0;
            border-radius: 1rem;
            padding: 1.25rem;
            margin-bottom: 1.25rem;
            background-color: #fdfefe;
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }
        .chat-message {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        .chat-message.user {
            background-color: #d1ecf1;
            align-self: flex-end;
            margin-left: auto;
        }
        .chat-message.ai {
            background-color: #e9ecef;
            align-self: flex-start;
            margin-right: auto;
        }
        .chat-input-area {
            display: flex;
            gap: 0.75rem;
        }
        #chatInput {
            flex-grow: 1;
            margin-bottom: 0;
        }
    </style>
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
</head>
<body>
    <!-- Hamburger Menu Button -->
    <button id="menuToggleButton" aria-label="Open menu" class="fixed top-4 left-4 z-50 bg-white shadow-lg rounded-full flex items-center justify-center w-11 h-11 focus:outline-none focus:ring-2 focus:ring-blue-400" style="box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <svg id="menuIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- Sidebar Overlay -->
    <div id="sidebarOverlay" class="fixed inset-0 bg-black bg-opacity-30 z-30 transition-opacity duration-300 ease-in-out opacity-0 pointer-events-none"></div>

    <!-- Sidebar Menu -->
    <div id="sidebarMenu" class="fixed top-0 left-0 h-full w-64 bg-white shadow-2xl z-40 transform -translate-x-full transition-transform duration-300 ease-in-out flex flex-col pt-0" style="box-shadow: 0 8px 32px rgba(0,0,0,0.18);">
        <nav class="flex flex-col gap-4 px-8 mt-20">
            <button class="text-lg font-semibold text-blue-600 hover:bg-blue-50 rounded-lg py-2 px-4 text-left transition">Surf Forecast</button>
            <button class="text-lg font-semibold text-blue-600 hover:bg-blue-50 rounded-lg py-2 px-4 text-left transition">Interactive Map</button>
            <button class="text-lg font-semibold text-blue-600 hover:bg-blue-50 rounded-lg py-2 px-4 text-left transition">My Spots</button>
            <button class="text-lg font-semibold text-blue-600 hover:bg-blue-50 rounded-lg py-2 px-4 text-left transition">My Quiver</button>
            <button class="text-lg font-semibold text-blue-600 hover:bg-blue-50 rounded-lg py-2 px-4 text-left transition">Journal</button>
        </nav>
        <div class="mt-auto px-8 pb-8 flex flex-col gap-2">
            <button id="myAccountButton" class="w-full bg-gray-200 hover:bg-gray-300 text-blue-700 font-bold py-2 px-4 rounded-lg shadow transition">My Account</button>
            <button id="loginButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow transition">Log In</button>
        </div>
    </div>
    <div class="container main-content-area" id="mainContentArea" aria-label="Main content area">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">Jersey Shore Surf Buddy</h1>
        <p class="text-gray-600 mb-8 text-lg">Your go-to for quick surf checks and local insights.</p>

        <div class="mb-4">
            <select id="njSpotsDropdown" class="w-full" aria-label="Select a New Jersey Surf Spot" tabindex="0">
                <option value="">Select a New Jersey Surf Spot</option>
            </select>
        </div>
        <button id="getForecastForSelectedSpotButton" aria-label="Get Forecast" tabindex="0">Get Forecast</button>

        <div id="loading-indicator">Paddling out for data...</div>

        <div id="result-container" class="hidden">
            <div id="feedback-container" class="hidden">
                <p class="font-semibold text-center mb-2">Did you surf here today?</p>
                <div id="feedback-initial" class="flex justify-center gap-4">
                    <button id="feedback-yes" class="bg-green-500 hover:bg-green-600" aria-label="Yes, I surfed here today" tabindex="0">Yes</button>
                    <button id="feedback-no" class="bg-red-500 hover:bg-red-600" aria-label="No, I did not surf here today" tabindex="0">No</button>
                </div>
                <div id="feedback-board" class="hidden flex flex-col items-center gap-2 mt-4">
                    <label for="board-select" class="font-semibold">Which board did you use?</label>
                    <select id="board-select" class="border rounded-lg px-3 py-2">
                        <option value="">Select a board</option>
                        <option value="Beacon (9'6)">Beacon (9'6)</option>
                        <option value="Seaside & Beyond (7')">Seaside & Beyond (7')</option>
                        <option value="Spitfire (6'4)">Spitfire (6'4)</option>
                        <option value="Puddle Jumper (5'8)">Puddle Jumper (5'8)</option>
                    </select>
                    <button id="board-select-next" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-4 rounded-lg shadow transition">Next</button>
                </div>
                <div id="feedback-rating" class="hidden">
                    <p class="font-semibold text-center mb-2">How was it? Rate your session:</p>
                    <div id="star-rating" class="flex justify-center items-center gap-2 text-3xl text-gray-400">
                        <span class="star" data-value="1">★</span>
                        <span class="star" data-value="2">★</span>
                        <span class="star" data-value="3">★</span>
                        <span class="star" data-value="4">★</span>
                        <span class="star" data-value="5">★</span>
                    </div>
                </div>
                <div id="feedback-details" class="hidden flex flex-col items-center gap-2 mt-4">
                    <label for="feedback-details-input" class="font-semibold text-center">Any specific details you want to share? <span class="font-normal">This will help curate your forecasts for future sessions.</span></label>
                    <textarea id="feedback-details-input" rows="3" class="w-full max-w-md px-4 py-2 rounded-lg border border-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Type your feedback..."></textarea>
                    <button id="feedback-details-submit" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-6 rounded-lg shadow transition">Submit</button>
                </div>
                <p id="feedback-thanks" class="hidden text-center font-bold text-green-600">Thanks for the feedback! We'll take this into consideration for future scoring at this spot.</p>
            </div>
            <div id="teaser-container" class="hidden">
                <h2 class="text-2xl font-bold text-white mb-3">Teaser</h2>
                <iframe id="teaser-iframe" width="100%" height="315" src="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-2xl font-bold text-gray-800">Current Conditions</h2>
                <div id="surf-score-container-header" class="visual-item">
                    <div class="surf-score-circle" id="surf-score-circle">
                        <span id="surf-score-value">--</span>
                    </div>
                    <span id="surf-score-label" class="mt-1"></span>
                </div>
            </div>
            <p id="forecast-location" class="text-xl font-semibold text-gray-700 mb-4"></p>

            <div class="forecast-visuals">
                 <div class="visual-item">
                    <div id="weatherIconContainer"></div>
                    <span id="airTempVisualText"></span>
                </div>
                 <div class="visual-item">
                    <svg class="w-8 h-8 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="swellPeriodVisualText"></span>
                </div>
                <div class="visual-item">
                    <div class="wave-bar-container">
                        <div id="waveBar" class="wave-bar"></div>
                    </div>
                    <span id="waveHeightVisualText"></span>
                </div>
                <div class="visual-item">
                    <div class="wind-strength-bar-container">
                        <div id="windStrengthBar" class="wind-strength-bar"></div>
                    </div>
                    <span id="windStrengthVisualText"></span>
                    <span id="windDirectionStatusText"></span>
                </div>
                 <div class="visual-item">
                    <div id="waterTempIndicator" class="water-temp-indicator"></div>
                    <span id="waterTempVisualText"></span>
                </div>
                <div class="visual-item">
                    <svg id="tideStatusArrow" class="w-8 h-8 text-blue-500 transition-transform duration-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 19V5m-7 7l7-7 7 7"/>
                    </svg>
                    <span id="tideStatusVisualText" class="font-bold"></span>
                </div>
            </div>
             <div class="sub-scores-container">
                <div class="visual-item">
                    <h3 class="font-bold text-lg">Clean Score</h3>
                    <span id="clean-score-value" class="text-2xl font-bold">--</span>
                </div>
                 <div class="visual-item">
                    <h3 class="font-bold text-lg">Size Score</h3>
                    <span id="size-score-value" class="text-2xl font-bold">--</span>
                </div>
            </div>
            <p id="forecast-text" class="text-lg leading-relaxed mt-6"></p>

            <div class="new-charts-section">
                <div class="chart-nav">
                    <button id="prevDayButton" disabled>&lt; Prev Day</button>
                    <h2 id="hourly-forecast-date" class="text-2xl font-bold text-gray-800">Hourly Forecast</h2>
                    <button id="nextDayButton">Next Day &gt;</button>
                </div>
                <div class="grid grid-cols-1 gap-8">
                    <div>
                        <h3 class="font-semibold text-center">Tide Chart</h3>
                        <canvas id="tideChartCanvas" class="chart-canvas"></canvas>
                        <p id="current-tide-status"></p>
                        <p id="next-tide-info"></p>
                    </div>
                    <div>
                        <h3 class="font-semibold text-center">Wave Height (ft)</h3>
                        <canvas id="waveHeightChartCanvas" class="chart-canvas"></canvas>
                    </div>
                    <div>
                        <h3 class="font-semibold text-center">Swell Period (s)</h3>
                        <canvas id="periodChartCanvas" class="chart-canvas"></canvas>
                    </div>
                    <div>
                        <h3 class="font-semibold text-center">Wind (knots)</h3>
                        <canvas id="windChartCanvas" class="chart-canvas"></canvas>
                    </div>
                     <div>
                        <h3 class="font-semibold text-center">Wind Direction</h3>
                        <canvas id="windDirectionChartCanvas" class="chart-canvas"></canvas>
                    </div>
                    <div>
                        <h3 class="font-semibold text-center">Weather</h3>
                        <canvas id="weatherChartCanvas" class="chart-canvas"></canvas>
                    </div>
                </div>
            </div>
            <div class="chat-container">
                <h2 class="text-2xl font-bold text-gray-800 mb-3">Chat with the Surf Buddy</h2>
                <div id="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="chatInput" placeholder="Ask about the surf..." aria-label="Chat input" tabindex="0">
                    <button id="chatSendButton" aria-label="Send chat message" tabindex="0">Send</button>
                </div>
            </div>
        </div>
        <!-- Community Feed Section -->
        <div id="community-feed" class="mt-10 p-6 bg-blue-50 rounded-2xl shadow-inner border border-blue-200 hidden">
            <h2 class="text-2xl font-bold mb-4 flex items-center gap-2 justify-center text-black">
                <svg class="w-7 h-7 text-black" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8h2a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8a2 2 0 012-2h2M15 3h-6a2 2 0 00-2 2v3a2 2 0 002 2h6a2 2 0 002-2V5a2 2 0 00-2-2z"/></svg>
                Community Feed
            </h2>
            <div class="mb-6 flex flex-col gap-2" id="community-post-area">
                <input id="community-post-input" type="text" placeholder="Share your surf experience..." class="w-full max-w-md px-4 py-2 rounded-lg border border-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-400" />
                <button id="community-post-btn" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow transition">Post</button>
            </div>
            <ul class="space-y-5" id="community-comments-list" style="width: 100%; max-width: 500px; margin: 0 auto;">
                <!-- Comments will be injected here -->
            </ul>
        </div>
    </div>

    <!-- Interactive Map Overlay -->
    <div id="interactiveMapOverlay" class="fixed inset-0 z-50 bg-white bg-opacity-95 flex flex-col items-center justify-center hidden">
        <button id="closeMapButton" class="absolute top-6 right-8 bg-blue-600 text-white rounded-full px-4 py-2 font-bold shadow hover:bg-blue-700">Close Map</button>
        <div id="maplibreMap" style="width: 90vw; height: 80vh; max-width: 900px; max-height: 90vh; min-height: 500px; border-radius: 1.5rem; box-shadow: 0 8px 32px rgba(0,0,0,0.18);"></div>
        <div id="mapForecastPopup" class="absolute left-1/2 top-20 transform -translate-x-1/2 bg-white border border-blue-200 rounded-xl shadow-lg p-5 min-w-[300px] hidden" style="z-index:60;"></div>
    </div>

    <script>
        const STORMGLASS_API_KEY = "e0d9d084-5431-11f0-89b2-0242ac130006-e0d9d0de-5431-11f0-89b2-0242ac130006";
        let tideChartInterval = null;
        let waveHeightChart, periodChart, windChart, tideChartInstance, windDirectionChart, weatherChart;
        let allForecastHours = [];
        let allTideData = { hourly: [], hilo: [] };
        let currentDisplayDate = new Date();
        let currentSpotName = '';

        const NJ_SURF_SPOTS = [
            { name: "Manasquan Inlet", lat: 40.1130, lon: -74.0410, camId: "71unjYWqD7A", parking: "Metered street parking nearby. Can fill up early on weekends." },
            { name: "Belmar - 16th Ave", lat: 40.1760, lon: -74.0150, camId: "oetWk6Y14H4", parking: "Free street parking, but limited. Some paid lots in summer." },
            { name: "Asbury Park", lat: 40.2229, lon: -74.0102, camId: "ZOvkUjiUL7I", parking: "Metered street parking and paid lots. Can be crowded on weekends." },
            { name: "Long Branch", lat: 40.2930, lon: -73.9900, camId: "6lpYssVuTRQ", parking: "Paid lots and metered street parking. Free parking several blocks inland." },
            { name: "Seaside Heights / Casino Pier", lat: 39.9400, lon: -74.0700, camId: "oL7IPIbaGi8", parking: "Paid lots and metered parking near the boardwalk." },
            { name: "Surf City", lat: 39.6596, lon: -74.1708, camId: "UzjrgjYz7bI", parking: "Free street parking, but fills up quickly in summer." },
            { name: "Atlantic City", lat: 39.3643, lon: -74.4229, camId: "Z5zpR-eFTbs", parking: "Plenty of paid lots and garages near the boardwalk." },
            { name: "Ocean City", lat: 39.2780, lon: -74.5770, camId: "lrhWDrz8Mc8", parking: "Metered street parking and paid lots. Free parking further from the beach." },
            { name: "Cape May (Broadway Beach)", lat: 38.9300, lon: -74.9100, camId: "YNTnKXA2nKU", parking: "Metered parking near the beach. Free parking several blocks away." },
            { name: "Long Beach Island (LBI)", lat: 39.6900, lon: -74.1000, camId: "WZ5isqHBkSo", parking: "Free street parking, but limited near popular peaks." }
        ];

        function metersToFeet(meters) { return meters * 3.28084; }
        function celsiusToFahrenheit(celsius) { return (celsius * 9 / 5) + 32; }

        function recommendBoard(waveHeightFeet) {
            if (waveHeightFeet < 2) return "Beacon (9'6)";
            if (waveHeightFeet < 3) return "Puddle Jumper (5'8)";
            if (waveHeightFeet < 4) return "Seaside & Beyond (7')";
            if (waveHeightFeet < 6) return "Spitfire (6'4)";
            return "Spitfire (6'4)";
        }

        function interpretWaveHeight(waveHeightMeters, swellPeriodSeconds, userName = 'you') {
            const waveHeightFeet = metersToFeet(waveHeightMeters).toFixed(1);
            const board = recommendBoard(Number(waveHeightFeet));
            let heightDescription;
            let boardRecommendation = `Based on your previous sessions in similar conditions, you will likely have fun today if you take out your ${board} and wear your 2mm springsuit.`;

            if (waveHeightMeters < 0.5) {
                heightDescription = `It's looking pretty flat right now (${waveHeightFeet} ft). Not much to ride.`;
            } else if (waveHeightMeters < 1.5) {
                heightDescription = `Fun, manageable waves around ${waveHeightFeet} ft.`;
            } else if (waveHeightMeters < 2.5) {
                heightDescription = `Solid surf hitting about ${waveHeightFeet} ft.`;
            } else {
                heightDescription = `Big, challenging waves at ${waveHeightFeet} ft.`;
            }

            let periodDescription = '';
            if (typeof swellPeriodSeconds === 'number') {
                if (swellPeriodSeconds < 6) periodDescription = `The swell period is short at ${swellPeriodSeconds.toFixed(0)}s, so the waves will be weaker.`;
                else if (swellPeriodSeconds < 10) periodDescription = `With a decent ${swellPeriodSeconds.toFixed(0)}s swell period, the waves should have some push.`;
                else periodDescription = `The long ${swellPeriodSeconds.toFixed(0)}s swell period is generating some powerful, quality groundswell.`;
            }
            let desc = `${heightDescription}`;
            if (periodDescription) desc += ' ' + periodDescription;
            desc += ' ' + boardRecommendation;
            return desc.trim();
        }

        function interpretWind(windSpeedMetersPerSec, windDirectionDegrees) {
            const knots = (windSpeedMetersPerSec * 1.94384).toFixed(1);
            let directionText = '';
            if (windDirectionDegrees >= 337.5 || windDirectionDegrees < 22.5) directionText = 'North';
            else if (windDirectionDegrees < 67.5) directionText = 'Northeast';
            else if (windDirectionDegrees < 112.5) directionText = 'East';
            else if (windDirectionDegrees < 157.5) directionText = 'Southeast';
            else if (windDirectionDegrees < 202.5) directionText = 'South';
            else if (windDirectionDegrees < 247.5) directionText = 'Southwest';
            else if (windDirectionDegrees < 292.5) directionText = 'West';
            else directionText = 'Northwest';

            let windImpactStatus = '';
            if (windDirectionDegrees >= 225 && windDirectionDegrees < 315) windImpactStatus = 'Offshore';
            else if (windDirectionDegrees >= 45 && windDirectionDegrees < 135) windImpactStatus = 'Onshore';
            else windImpactStatus = 'Cross-shore';
            document.getElementById('windDirectionStatusText').textContent = `(${windImpactStatus})`;

            let windStrength = '';
            if (knots < 5) windStrength = 'light';
            else if (knots < 10) windStrength = 'gentle';
            else if (knots < 15) windStrength = 'moderate';
            else if (knots < 20) windStrength = 'fresh';
            else windStrength = 'strong';

            return `Winds are ${windStrength} from the ${directionText} (${knots} knots), creating ${windImpactStatus} conditions.`;
        }

        function determineSurfConditions(waveHeightMeters, swellPeriodSeconds, windSpeedMetersPerSec, windDirectionDegrees) {
            const waveHeightFeet = metersToFeet(waveHeightMeters);
            const windKnots = windSpeedMetersPerSec * 1.94384;
            let score = 0;
            if (waveHeightFeet > 1.5 && waveHeightFeet < 5) score += 40;
            else if (waveHeightFeet >= 1 && waveHeightFeet <= 6) score += 25;
            else if (waveHeightFeet > 6) score += 10;
            if (swellPeriodSeconds >= 8) score += 30;
            else if (swellPeriodSeconds >= 6) score += 20;
            else score += 5;
            if (windDirectionDegrees >= 225 && windDirectionDegrees <= 315) {
                if(windKnots < 12) score += 30; else score += 15;
            } else if (windDirectionDegrees < 45 || windDirectionDegrees > 315 || (windDirectionDegrees > 135 && windDirectionDegrees < 225)) {
                 if(windKnots < 8) score += 15;
            } else {
                if(windKnots > 15) score -= 20; else if (windKnots > 8) score -=10;
            }
            return Math.max(0, Math.min(100, score));
        }

        function calculateCleanScore(windSpeedMetersPerSec, windDirectionDegrees, swellPeriodSeconds) {
            let score = 0;
            const windKnots = windSpeedMetersPerSec * 1.94384;
            if (windDirectionDegrees >= 225 && windDirectionDegrees <= 315) {
                if(windKnots < 7) score += 60; else if(windKnots < 12) score += 45; else score += 20;
            } else if (windDirectionDegrees < 45 || windDirectionDegrees > 315 || (windDirectionDegrees > 135 && windDirectionDegrees < 225)) {
                 if(windKnots < 5) score += 40; else if(windKnots < 10) score += 20;
            } else {
                if(windKnots < 5) score += 15;
            }
            if (swellPeriodSeconds >= 10) score += 40;
            else if (swellPeriodSeconds >= 7) score += 30;
            else if (swellPeriodSeconds >= 5) score += 15;
            return Math.max(0, Math.min(100, score));
        }

        function calculateSizeScore(waveHeightMeters) {
            const waveHeightFeet = metersToFeet(waveHeightMeters);
            if (waveHeightFeet < 1) return 10;
            if (waveHeightFeet < 2) return 30;
            if (waveHeightFeet < 3) return 50;
            if (waveHeightFeet < 4) return 70;
            if (waveHeightFeet < 6) return 90;
            return 100;
        }

        function updateSurfScoreVisual(score) {
            const surfScoreCircle = document.getElementById('surf-score-circle');
            const surfScoreValue = document.getElementById('surf-score-value');
            const surfScoreLabel = document.getElementById('surf-score-label');
            if (!surfScoreCircle || !surfScoreValue || !surfScoreLabel) return;

            surfScoreValue.textContent = score.toFixed(0);

            if (score >= 70) {
                surfScoreCircle.style.borderColor = '#22c55e';
                surfScoreLabel.textContent = 'Good';
            } else if (score >= 40) {
                surfScoreCircle.style.borderColor = '#f59e0b';
                surfScoreLabel.textContent = 'Fair';
            } else {
                surfScoreCircle.style.borderColor = '#ef4444';
                surfScoreLabel.textContent = 'Poor';
            }
        }

        function updateWaveVisualization(waveHeightMeters) {
            const waveBar = document.getElementById('waveBar');
            const waveHeightVisualText = document.getElementById('waveHeightVisualText');
            if (waveBar && waveHeightVisualText) {
                const maxFeet = 12;
                const waveHeightFeet = metersToFeet(waveHeightMeters);
                let percentage = (waveHeightFeet / maxFeet) * 100;
                if (percentage > 100) percentage = 100;
                waveBar.style.height = `${percentage}%`;
                waveHeightVisualText.textContent = `${waveHeightFeet.toFixed(1)}ft`;
            }
        }

        function updateWindStrengthVisual(windSpeedMetersPerSec) {
            const windStrengthBar = document.getElementById('windStrengthBar');
            const windStrengthVisualText = document.getElementById('windStrengthVisualText');
            if (windStrengthBar && windStrengthVisualText) {
                const maxWindKnots = 30;
                const windKnots = windSpeedMetersPerSec * 1.94384;
                let percentage = (windKnots / maxWindKnots) * 100;
                if (percentage > 100) percentage = 100;
                windStrengthBar.style.width = `${percentage}%`;
                if (percentage < 25) windStrengthBar.style.background = 'linear-gradient(to right, #a7f3d0, #6ee7b7)';
                else if (percentage < 50) windStrengthBar.style.background = 'linear-gradient(to right, #fde68a, #fbbf24)';
                else if (percentage < 75) windStrengthBar.style.background = 'linear-gradient(to right, #fdba74, #f97316)';
                else windStrengthBar.style.background = 'linear-gradient(to right, #fca5a5, #ef4444)';
                windStrengthVisualText.textContent = `${windKnots.toFixed(0)} knots`;
            }
        }

        function updateSwellDirectionCompass(swellDirectionDegrees) {
            const swellArrow = document.getElementById('swellArrow');
            if (swellArrow) {
                swellArrow.style.transform = `translate(-50%, -100%) rotate(${swellDirectionDegrees}deg)`;
            }
        }

        function updateWaterTemperatureVisual(tempCelsius) {
            const waterTempIndicator = document.getElementById('waterTempIndicator');
            const waterTempVisualText = document.getElementById('waterTempVisualText');
            if (waterTempIndicator && waterTempVisualText) {
                let color = '#ccc', tempFahrenheit = 'N/A';
                if (typeof tempCelsius === 'number') {
                    tempFahrenheit = celsiusToFahrenheit(tempCelsius);
                    if (tempFahrenheit < 50) color = '#bfdbfe';
                    else if (tempFahrenheit < 60) color = '#93c5fd';
                    else if (tempFahrenheit < 70) color = '#60a5fa';
                    else if (tempFahrenheit < 80) color = '#3b82f6';
                    else color = '#2563eb';
                }
                waterTempIndicator.style.backgroundColor = color;
                waterTempVisualText.textContent = tempFahrenheit !== 'N/A' ? `${tempFahrenheit.toFixed(1)}°F` : 'N/A';
            }
        }

        function updateWeatherVisual(cloudCover, airTempCelsius) {
            const weatherIconContainer = document.getElementById('weatherIconContainer');
            const airTempVisualText = document.getElementById('airTempVisualText');
            if (!weatherIconContainer || !airTempVisualText) return;

            let iconSvg = '';
            if (cloudCover < 25) { // Sunny
                iconSvg = `<svg class="w-8 h-8 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>`;
            } else if (cloudCover < 75) { // Partly Cloudy
                iconSvg = `<svg class="w-8 h-8 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12h1m8-9v1m8.366 6.634l-.707-.707M5.636 5.636L4.93 4.93M19 12h1M4 12h1m14-4a8.003 8.003 0 00-14.89 3.12A5.5 5.5 0 005.5 22h13a5.5 5.5 0 001.41-10.88A8 8 0 0019 4z"></path></svg>`;
            } else { // Cloudy
                iconSvg = `<svg class="w-8 h-8 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12h1m8-9v1m8.366 6.634l-.707-.707M5.636 5.636L4.93 4.93M19 12h1M4 12h1m14-4a8.003 8.003 0 00-14.89 3.12A5.5 5.5 0 005.5 22h13a5.5 5.5 0 001.41-10.88A8 8 0 0019 4z"></path></svg>`;
            }
            weatherIconContainer.innerHTML = iconSvg;

            if (typeof airTempCelsius === 'number') {
                airTempVisualText.textContent = `${celsiusToFahrenheit(airTempCelsius).toFixed(0)}°F`;
            } else {
                airTempVisualText.textContent = 'N/A';
            }
        }

        function updateSwellPeriodVisual(swellPeriod) {
            const swellPeriodVisualText = document.getElementById('swellPeriodVisualText');
            if (!swellPeriodVisualText) return;
            swellPeriodVisualText.textContent = typeof swellPeriod === 'number' ? `${swellPeriod.toFixed(1)}s` : 'N/A';
        }

        function updateCurrentTideIndicator() {
             const tideStatusVisualText = document.getElementById('tideStatusVisualText');
             const tideStatusArrow = document.getElementById('tideStatusArrow');
             const currentTideStatusElement = document.getElementById('current-tide-status');
             const nextTideInfoElement = document.getElementById('next-tide-info');

            if (!allTideData) return;

            const hourlyData = allTideData.hourly;
            const hiloData = allTideData.hilo;

            const now = new Date();
            const nowUtcMs = now.getTime();

            let currentTideLevel = "N/A", tideStatus = "N/A";

            if (hourlyData && hourlyData.length > 0) {
                let prevPoint = null, nextPoint = null;
                for (let i = 0; i < hourlyData.length; i++) {
                    if (new Date(hourlyData[i].time).getTime() <= nowUtcMs) {
                        prevPoint = hourlyData[i];
                    } else {
                        nextPoint = hourlyData[i];
                        break;
                    }
                }
                if (prevPoint && nextPoint) {
                    const prevHeight = prevPoint.sg, nextHeight = nextPoint.sg;
                    if (typeof prevHeight === 'number' && typeof nextHeight === 'number') {
                        const timeFraction = (nowUtcMs - new Date(prevPoint.time).getTime()) / (new Date(nextPoint.time).getTime() - new Date(prevPoint.time).getTime());
                        currentTideLevel = metersToFeet(prevHeight + (nextHeight - prevHeight) * timeFraction).toFixed(1);
                        const difference = nextHeight - prevHeight;
                        if (Math.abs(difference) < 0.01) tideStatus = 'Slack';
                        else if (difference > 0) tideStatus = 'Rising Tide';
                        else tideStatus = 'Falling Tide';
                    }
                }
            }

            currentTideStatusElement.textContent = `Current Tide: ${isNaN(parseFloat(currentTideLevel)) ? '' : currentTideLevel + ' ft'} (${tideStatus})`;
            tideStatusVisualText.textContent = tideStatus;
            if (tideStatus === 'Rising Tide') tideStatusArrow.style.transform = 'rotate(0deg)';
            else if (tideStatus === 'Falling Tide') tideStatusArrow.style.transform = 'rotate(180deg)';
            else tideStatusArrow.style.transform = 'rotate(90deg)';

            if (nextTideInfoElement && Array.isArray(hiloData) && hiloData.length > 0) {
                // Debug log
                console.log('hiloData:', hiloData);
                console.log('now:', now.toISOString());
                // Sort events by time ascending
                const sortedHilo = hiloData.slice().sort((a, b) => new Date(a.time) - new Date(b.time));
                const nowMs = now.getTime();
                const nextTideEvent = sortedHilo.find(event => new Date(event.time).getTime() > nowMs);
                if (nextTideEvent && nextTideEvent.type && typeof nextTideEvent.height === 'number') {
                    const timeString = new Date(nextTideEvent.time).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                    nextTideInfoElement.textContent = `Next ${nextTideEvent.type} tide is at ${timeString}.`;
                } else {
                    // Fallback: show soonest event for debugging
                    if (sortedHilo.length > 0) {
                        const soonest = sortedHilo[0];
                        const timeString = new Date(soonest.time).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                        const heightString = metersToFeet(soonest.height).toFixed(1);
                        nextTideInfoElement.textContent = `[Debug] Soonest: ${soonest.type} tide is ${heightString}ft at ${timeString}.`;
                } else {
                    nextTideInfoElement.textContent = 'No more tide events scheduled in the next 48 hours.';
                    }
                }
            }
        }

        function drawTideChart(hourlyData, currentTime) {
             const tideChartCanvas = document.getElementById('tideChartCanvas');
             const tideChartCtx = tideChartCanvas.getContext('2d');
             if (!tideChartCanvas || !tideChartCtx) return;

            if(tideChartInstance) tideChartInstance.destroy();

            const labels = hourlyData.map(d => new Date(d.time));
            const data = hourlyData.map(d => metersToFeet(d.sg));

            // Create gradient for tide chart
            const gradient = tideChartCtx.createLinearGradient(0, 0, 0, tideChartCanvas.height);
            gradient.addColorStop(0, '#38bdf8'); // blue
            gradient.addColorStop(1, '#a5b4fc'); // purple

            tideChartInstance = new Chart(tideChartCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Tide Height (ft)',
                        data: data,
                        borderColor: '#6366f1',
                        backgroundColor: gradient,
                        fill: true,
                        tension: 0.45,
                        pointRadius: 5,
                        pointBackgroundColor: '#6366f1',
                        pointBorderWidth: 2,
                        pointHoverRadius: 8,
                        pointHoverBackgroundColor: '#38bdf8',
                        shadowOffsetX: 0,
                        shadowOffsetY: 4,
                        shadowBlur: 10,
                        shadowColor: 'rgba(99,102,241,0.2)'
                    }]
                },
                options: {
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#18181b',
                            titleColor: '#38bdf8',
                            bodyColor: '#fff',
                            borderColor: '#6366f1',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: false,
                            callbacks: {
                                label: ctx => ` ${ctx.parsed.y.toFixed(2)} ft`
                            }
                        },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                currentTimeLine: {
                                    type: 'line',
                                    scaleID: 'x',
                                        value: currentTime,
                                        borderColor: '#f59e42',
                                        borderWidth: 2,
                                        borderDash: [6, 6]
                                    }
                                } : {})
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'hour', displayFormats: { hour: 'ha' } },
                            title: { display: true, text: 'Time', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        },
                        y: {
                            title: { display: true, text: 'Tide Height (ft)', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            beginAtZero: false,
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        }
                    }
                }
            });
        }

        function createOrUpdateChart(chartInstance, canvasId, chartConfig) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstance) chartInstance.destroy();
            return new Chart(ctx, chartConfig);
        }

        function drawHourlyCharts(hourlyData, currentTime) {
            const now = new Date();
            const futureData = hourlyData.filter(h => new Date(h.time) >= now);
            const labels = hourlyData.map(h => new Date(h.time));
            const futureLabels = futureData.map(h => new Date(h.time));

            const annotationPlugin = {
                id: 'currentTimeLine',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    const x = xAxis.getPixelForValue(now);

                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'red';
                    ctx.stroke();
                    ctx.restore();
                }
            };

            const sunnyIcon = new Image(20, 20);
            sunnyIcon.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>');
            const partlyCloudyIcon = new Image(20, 20);
            partlyCloudyIcon.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#718096" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path><path d="M12 2v2"></path><path d="M12 18v2"></path><path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="M6.34 17.66l-1.41 1.41"></path><path d="M19.07 4.93l-1.41 1.41"></path></svg>');
            const cloudyIcon = new Image(20, 20);
            cloudyIcon.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4a5568" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 10A8 8 0 1 0 6 18h12a5 5 0 0 0 0-10z"></path></svg>');
            // Wind arrow icon as a function to rotate
            function createWindArrowIcon(degrees) {
                const size = 24;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.save();
                ctx.translate(size/2, size/2);
                ctx.rotate((degrees-180) * Math.PI / 180); // -180 so arrow points to where wind is going
                ctx.translate(-size/2, -size/2);
                ctx.drawImage(windArrowIcon, 0, 0, size, size);
                ctx.restore();
                const img = new Image(size, size);
                img.src = canvas.toDataURL();
                return img;
            }
            const windArrowIcon = new Image(24,24);
            windArrowIcon.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#3b82f6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>');

            waveHeightChart = createOrUpdateChart(waveHeightChart, 'waveHeightChartCanvas', {
                type: 'bar',
                data: { labels, datasets: [{ label: 'Wave Height (ft)', data: hourlyData.map(h => metersToFeet(h.waveHeight.sg)), backgroundColor: function(ctx) {
                    const chart = ctx.chart;
                    const {ctx: c, chartArea} = chart;
                    if (!chartArea) return '#38bdf8';
                    const gradient = c.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    gradient.addColorStop(0, '#38bdf8');
                    gradient.addColorStop(1, '#06b6d4');
                    return gradient;
                }, borderRadius: 8, borderSkipped: false, barPercentage: 0.7, categoryPercentage: 0.7, shadowOffsetX: 0, shadowOffsetY: 4, shadowBlur: 10, shadowColor: 'rgba(6,182,212,0.15)' }] },
                options: {
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#18181b',
                            titleColor: '#38bdf8',
                            bodyColor: '#fff',
                            borderColor: '#06b6d4',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: false,
                            callbacks: {
                                label: ctx => ` ${ctx.parsed.y.toFixed(2)} ft`
                            }
                        },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                    currentTimeLine: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: currentTime,
                                        borderColor: '#f59e42',
                                        borderWidth: 2,
                                        borderDash: [6, 6]
                                    }
                                } : {})
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'hour', displayFormats: { hour: 'ha' } },
                            title: { display: true, text: 'Time', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        },
                        y: {
                            title: { display: true, text: 'Wave Height (ft)', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            beginAtZero: true,
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        }
                    }
                }
            });
            periodChart = createOrUpdateChart(periodChart, 'periodChartCanvas', {
                type: 'line',
                data: { labels, datasets: [{ label: 'Swell Period (s)', data: hourlyData.map(h => h.swellPeriod.sg), borderColor: '#a21caf', backgroundColor: function(ctx) {
                    const chart = ctx.chart;
                    const {ctx: c, chartArea} = chart;
                    if (!chartArea) return '#a21caf';
                    const gradient = c.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    gradient.addColorStop(0, '#a21caf');
                    gradient.addColorStop(1, '#f472b6');
                    return gradient;
                }, fill: true, tension: 0.45, pointRadius: 5, pointBackgroundColor: '#a21caf', pointHoverRadius: 8, pointHoverBackgroundColor: '#f472b6', borderWidth: 4, shadowOffsetX: 0, shadowOffsetY: 4, shadowBlur: 10, shadowColor: 'rgba(162,28,175,0.15)' }] },
                options: {
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#18181b',
                            titleColor: '#a21caf',
                            bodyColor: '#fff',
                            borderColor: '#f472b6',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: false,
                            callbacks: {
                                label: ctx => ` ${ctx.parsed.y.toFixed(2)} s`
                            }
                        },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                    currentTimeLine: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: currentTime,
                                        borderColor: '#f59e42',
                                        borderWidth: 2,
                                        borderDash: [6, 6]
                                    }
                                } : {})
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'hour', displayFormats: { hour: 'ha' } },
                            title: { display: true, text: 'Time', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        },
                        y: {
                            title: { display: true, text: 'Swell Period (s)', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            beginAtZero: true,
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        }
                    }
                }
            });
            windChart = createOrUpdateChart(windChart, 'windChartCanvas', {
                type: 'line',
                data: { labels, datasets: [{ label: 'Wind Speed (knots)', data: hourlyData.map(h => h.windSpeed.sg * 1.94384), borderColor: '#0ea5e9', backgroundColor: function(ctx) {
                    const chart = ctx.chart;
                    const {ctx: c, chartArea} = chart;
                    if (!chartArea) return '#0ea5e9';
                    const gradient = c.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
                    gradient.addColorStop(0, '#0ea5e9');
                    gradient.addColorStop(1, '#38bdf8');
                    return gradient;
                }, fill: true, tension: 0.45, pointRadius: 5, pointBackgroundColor: '#0ea5e9', pointHoverRadius: 8, pointHoverBackgroundColor: '#38bdf8', borderWidth: 4, shadowOffsetX: 0, shadowOffsetY: 4, shadowBlur: 10, shadowColor: 'rgba(14,165,233,0.15)' }] },
                options: {
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#18181b',
                            titleColor: '#0ea5e9',
                            bodyColor: '#fff',
                            borderColor: '#38bdf8',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: false,
                            callbacks: {
                                label: ctx => ` ${ctx.parsed.y.toFixed(2)} knots`
                            }
                        },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                    currentTimeLine: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: currentTime,
                                        borderColor: '#f59e42',
                                        borderWidth: 2,
                                        borderDash: [6, 6]
                                    }
                                } : {})
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'hour', displayFormats: { hour: 'ha' } },
                            // min: now, // Allow full day
                            title: { display: true, text: 'Time', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        },
                        y: {
                            title: { display: true, text: 'Wind Speed (knots)', color: '#334155', font: { size: 16, weight: 'bold', family: 'Inter' } },
                            beginAtZero: true,
                            grid: { display: false },
                            ticks: { color: '#334155', font: { size: 14, family: 'Inter' } }
                        }
                    }
                }
            });
            // Wind direction chart as arrows
             windDirectionChart = createOrUpdateChart(windDirectionChart, 'windDirectionChartCanvas', {
                type: 'scatter',
                data: {
                    labels,
                    datasets: [{
                        label: 'Wind Direction',
                        data: hourlyData.map(h => ({x: new Date(h.time), y: 180})), // y=180 for vertical center
                        pointStyle: hourlyData.map(h => createWindArrowIcon(h.windDirection.sg)),
                        pointRadius: 15,
                        showLine: false,
                    }]
                },
                options: {
                    scales: {
                        x: { type: 'time', time: { unit: 'hour', displayFormats: { hour: 'ha' } }, min: now, grid: { display: false } },
                        y: { display: false, min: 0, max: 360, grid: { display: false } }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                    currentTimeLine: {
                type: 'line',
                                        scaleID: 'x',
                                        value: currentTime,
                                        borderColor: 'red',
                                        borderWidth: 2
                                    }
                                } : {})
                            }
                        }
                    }
                },
                plugins: [annotationPlugin]
            });
            weatherChart = createOrUpdateChart(weatherChart, 'weatherChartCanvas', {
                type: 'line',
                data: {
                    labels: futureLabels,
                    datasets: [{
                        label: 'Weather',
                        data: futureData.map(() => 10),
                        borderColor: 'transparent',
                        backgroundColor: 'transparent',
                        pointStyle: futureData.map(h => {
                            if (!h.cloudCover) return false;
                            if (h.cloudCover.sg < 25) return sunnyIcon;
                            if (h.cloudCover.sg < 75) return partlyCloudyIcon;
                            return cloudyIcon;
                        }),
                        pointRadius: 15,
                    }]
                },
                options: {
                    scales: {
                        x: { type: 'time', time: { unit: 'hour', displayFormats: { hour: 'ha' } }, min: now, grid: { display: false } },
                        y: { display: false, min: 0, max: 20, grid: { display: false } }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                ...(currentTime ? {
                                currentTimeLine: {
                                    type: 'line',
                                    scaleID: 'x',
                                        value: currentTime,
                                    borderColor: 'red',
                                    borderWidth: 2
                                }
                                } : {})
                            }
                        },
                        datalabels: {
                            align: 'bottom',
                            offset: 10,
                            color: '#2c3e50',
                            font: { weight: 'bold' },
                            formatter: (value, context) => {
                                const dataPoint = futureData[context.dataIndex];
                                if (dataPoint && dataPoint.airTemperature) {
                                    return `${celsiusToFahrenheit(dataPoint.airTemperature.sg).toFixed(0)}°F`;
                                }
                                return '';
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, annotationPlugin]
            });
        }

        async function getSurfForecast(lat, lon, locationName) {
            const loadingIndicator = document.getElementById('loading-indicator');
            const resultContainer = document.getElementById('result-container');
            const forecastText = document.getElementById('forecast-text');
            const forecastLocation = document.getElementById('forecast-location');
            const liveCamContainer = document.getElementById('teaser-container');
            const liveCamIframe = document.getElementById('teaser-iframe');

            loadingIndicator.style.display = 'block';
            resultContainer.classList.add('hidden');
            forecastLocation.textContent = `Fetching forecast for ${locationName}...`;

            const selectedSpot = NJ_SURF_SPOTS.find(spot => spot.name === locationName);
            if (selectedSpot && selectedSpot.camId) {
                liveCamIframe.src = `https://www.youtube.com/embed/${selectedSpot.camId}?autoplay=1&mute=1`;
                liveCamContainer.classList.remove('hidden');
            } else {
                liveCamContainer.classList.add('hidden');
            }

            try {
                const now = new Date();
                // Always use current date for startDate
                const startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                // End date is 5 days ahead (max for Stormglass free tier)
                const weatherEndDate = new Date(startDate.getTime() + 5 * 24 * 60 * 60 * 1000);
                const params = `waveHeight,swellDirection,swellPeriod,windDirection,windSpeed,waterTemperature,airTemperature,cloudCover`;
                const weatherApiUrl = `https://api.stormglass.io/v2/weather/point?lat=${lat}&lng=${lon}&start=${startDate.toISOString()}&end=${weatherEndDate.toISOString()}&params=${params}`;
                const weatherResponse = await fetch(`http://localhost:4000/api/stormglass?url=${encodeURIComponent(weatherApiUrl)}`);
                if (!weatherResponse.ok) throw new Error('Failed to fetch weather data');
                const weatherData = await weatherResponse.json();
                allForecastHours = weatherData.hours;

                const firstForecastPoint = allForecastHours.find(h => new Date(h.time) >= now) || allForecastHours[0];
                if (firstForecastPoint) {
                    const { waveHeight, windSpeed, windDirection, waterTemperature, swellDirection, swellPeriod, airTemperature, cloudCover } = firstForecastPoint;

                    const score = determineSurfConditions(waveHeight.sg, swellPeriod.sg, windSpeed.sg, windDirection.sg);
                    updateSurfScoreVisual(score);

                    const baseDesc = interpretWaveHeight(waveHeight.sg, swellPeriod.sg);
                    const windDesc = interpretWind(windSpeed.sg, windDirection.sg);
                    // Extract the personalized message from interpretWaveHeight
                    const board = recommendBoard(Number(metersToFeet(waveHeight.sg).toFixed(1)));
                    const personalizedMsg = `Based on your previous sessions in similar conditions, you will likely have fun today if you take out your ${board} and wear your 2mm springsuit.`;
                    // Remove the personalized message from baseDesc if present
                    let mainDesc = baseDesc.replace(personalizedMsg, '').trim();
                    if (mainDesc.endsWith('.')) mainDesc = mainDesc.slice(0, -1);
                    forecastText.textContent = `${mainDesc}. ${windDesc} ${personalizedMsg}`.replace(/\s+/g, ' ').trim();
                    forecastLocation.textContent = locationName;

                    updateWaveVisualization(waveHeight.sg);
                    updateWindStrengthVisual(windSpeed.sg);
                    updateSwellDirectionCompass(swellDirection.sg);
                    updateWaterTemperatureVisual(waterTemperature.sg);
                    updateWeatherVisual(cloudCover.sg, airTemperature.sg);
                    updateSwellPeriodVisual(swellPeriod.sg);

                    const cleanScore = calculateCleanScore(windSpeed.sg, windDirection.sg, swellPeriod.sg);
                    const sizeScore = calculateSizeScore(waveHeight.sg);
                    document.getElementById('clean-score-value').textContent = cleanScore.toFixed(0);
                    document.getElementById('size-score-value').textContent = sizeScore.toFixed(0);

                    // Always set currentDisplayDate to today on initial load
                    const today = new Date();
                    currentDisplayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    displayHourlyDataForDate(currentDisplayDate);
                }

                // Tide data: 6 days ahead max
                const tideEndDate = new Date(startDate.getTime() + 6 * 24 * 60 * 60 * 1000);
                const tideParams = `lat=${lat}&lng=${lon}&start=${startDate.toISOString()}&end=${tideEndDate.toISOString()}`;
                const tideHourlyUrl = `https://api.stormglass.io/v2/tide/sea-level/point?${tideParams}`;
                const tideHiloUrl = `https://api.stormglass.io/v2/tide/extremes/point?${tideParams}`;
                const [tideHourlyResponse, tideHiloResponse] = await Promise.all([
                    fetch(`http://localhost:4000/api/stormglass?url=${encodeURIComponent(tideHourlyUrl)}`),
                    fetch(`http://localhost:4000/api/stormglass?url=${encodeURIComponent(tideHiloUrl)}`)
                ]);
                if (!tideHourlyResponse.ok || !tideHiloResponse.ok) throw new Error('Failed to fetch tide data');
                const hourlyTideData = await tideHourlyResponse.json();
                const hiloTideData = await tideHiloResponse.json();
                if (hourlyTideData.data?.length > 0 && hiloTideData.data?.length > 0) {
                    allTideData = { hourly: hourlyTideData.data, hilo: hiloTideData.data };
                    if (tideChartInterval) clearInterval(tideChartInterval);
                    updateCurrentTideIndicator();
                    tideChartInterval = setInterval(updateCurrentTideIndicator, 60000);
                    // Fix: ensure tide chart is drawn after tide data is loaded
                    displayHourlyDataForDate(currentDisplayDate);
                }
            } catch (error) {
                console.error('Error in getSurfForecast:', error);
                if (forecastText) forecastText.textContent = `Failed to fetch forecast: ${error.message}.`;
            } finally {
                loadingIndicator.style.display = 'none';
                resultContainer.classList.remove('hidden');
                document.getElementById('community-feed').classList.remove('hidden');
            }
        }

        function populateNJSpotsDropdown() {
            const njSpotsDropdown = document.getElementById('njSpotsDropdown');
            if (njSpotsDropdown) {
                NJ_SURF_SPOTS.forEach(spot => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify({ lat: spot.lat, lon: spot.lon, name: spot.name, camId: spot.camId });
                    option.textContent = spot.name;
                    njSpotsDropdown.appendChild(option);
                });
            }
        }

        function getCurrentTimeInEST() {
            // Get the current time in America/New_York as a Date object
            const now = new Date();
            const estString = now.toLocaleString('en-US', { timeZone: 'America/New_York' });
            return new Date(estString);
        }

        function displayHourlyDataForDate(date) {
            const filteredData = allForecastHours.filter(h => new Date(h.time).toDateString() === date.toDateString());
            document.getElementById('hourly-forecast-date').textContent = date.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric' });

            // Determine if the selected date is today (in local time)
            const today = new Date();
            const isToday = date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate();
            const currentTime = isToday ? getCurrentTimeInEST() : null;

            drawHourlyCharts(filteredData, currentTime);

            // Only show tide data for the selected day (today by default), comparing in local time
            const filteredTideData = allTideData.hourly.filter(h => {
                const t = new Date(h.time);
                return t.getFullYear() === date.getFullYear() && t.getMonth() === date.getMonth() && t.getDate() === date.getDate();
            });
            drawTideChart(filteredTideData, currentTime);

            document.getElementById('prevDayButton').disabled = date.toDateString() === today.toDateString();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const getForecastForSelectedSpotButton = document.getElementById('getForecastForSelectedSpotButton');
            const njSpotsDropdown = document.getElementById('njSpotsDropdown');
            const prevDayButton = document.getElementById('prevDayButton');
            const nextDayButton = document.getElementById('nextDayButton');
            const feedbackYesButton = document.getElementById('feedback-yes');
            const feedbackNoButton = document.getElementById('feedback-no');
            const feedbackContainer = document.getElementById('feedback-container');
            const feedbackInitial = document.getElementById('feedback-initial');
            const feedbackRating = document.getElementById('feedback-rating');
            const feedbackThanks = document.getElementById('feedback-thanks');
            const stars = document.querySelectorAll('.star');
            const chatSendButton = document.getElementById('chatSendButton');
            const chatInput = document.getElementById('chatInput');

            populateNJSpotsDropdown();

            if (getForecastForSelectedSpotButton) {
                getForecastForSelectedSpotButton.addEventListener('click', () => {
                    if (njSpotsDropdown.value) {
                        const spot = JSON.parse(njSpotsDropdown.value);
                        getSurfForecast(spot.lat, spot.lon, spot.name);
                        currentSpotName = spot.name; // Fix: update currentSpotName for chat context
                        feedbackContainer.classList.remove('hidden');
                        feedbackInitial.classList.remove('hidden');
                        feedbackRating.classList.add('hidden');
                        feedbackThanks.classList.add('hidden');
                    }
                });
            }

            prevDayButton.addEventListener('click', () => {
                currentDisplayDate.setDate(currentDisplayDate.getDate() - 1);
                displayHourlyDataForDate(currentDisplayDate);
            });

            nextDayButton.addEventListener('click', () => {
                currentDisplayDate.setDate(currentDisplayDate.getDate() + 1);
                displayHourlyDataForDate(currentDisplayDate);
            });

            const feedbackBoard = document.getElementById('feedback-board');
            const boardSelect = document.getElementById('board-select');
            const boardSelectNext = document.getElementById('board-select-next');

            feedbackYesButton.addEventListener('click', () => {
                feedbackInitial.classList.add('hidden');
                feedbackBoard.classList.remove('hidden');
            });

            boardSelectNext.addEventListener('click', () => {
                if (boardSelect.value) {
                    feedbackBoard.classList.add('hidden');
                    feedbackRating.classList.remove('hidden');
                } else {
                    boardSelect.classList.add('border-red-500');
                }
            });

            feedbackNoButton.addEventListener('click', () => {
                feedbackContainer.classList.add('hidden');
            });

            const feedbackDetails = document.getElementById('feedback-details');
            const feedbackDetailsInput = document.getElementById('feedback-details-input');
            const feedbackDetailsSubmit = document.getElementById('feedback-details-submit');

            stars.forEach(star => {
                star.addEventListener('click', () => {
                    feedbackRating.classList.add('hidden');
                    feedbackDetails.classList.remove('hidden');
                });
            });

            feedbackDetailsSubmit.addEventListener('click', () => {
                feedbackDetails.classList.add('hidden');
                feedbackThanks.classList.remove('hidden');
                // Optionally, you could collect feedbackDetailsInput.value here
            });

            chatSendButton.addEventListener('click', handleChatMessage);
            chatInput.addEventListener('keypress', (e) => {
                if(e.key === 'Enter') handleChatMessage();
            });

            renderCommunityFeed();
        });

        async function handleChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const chatMessages = document.getElementById('chat-messages');
            const userMessage = chatInput.value.trim();

            if (userMessage) {
                const userMessageDiv = document.createElement('div');
                userMessageDiv.className = 'chat-message user';
                userMessageDiv.textContent = userMessage;
                chatMessages.appendChild(userMessageDiv);
                chatInput.value = '';
                chatMessages.scrollTop = chatMessages.scrollHeight;

                const waterTemp = document.getElementById('waterTempVisualText').textContent;
                const forecastText = document.getElementById('forecast-text').textContent;
                let parkingInfo = '';
                if (/parking/i.test(userMessage)) {
                    const selectedSpot = NJ_SURF_SPOTS.find(spot => spot.name === currentSpotName);
                    if (selectedSpot && selectedSpot.parking) {
                        parkingInfo = `Parking info for ${selectedSpot.name}: ${selectedSpot.parking}`;
                    }
                }
                const prompt = `You are a surf forecasting expert. Keep your responses very short and to the point. Do not use any markdown formatting or asterisks. Based on the following data for ${currentSpotName}, answer the user's question: "${userMessage}". Forecast data: ${forecastText}. The water temperature is ${waterTemp}. ${parkingInfo}`;

                try {
                    // Call backend /rag endpoint to handle RAG logic
                    const ragResponse = await fetch('http://localhost:4000/rag', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ question: userMessage, fallbackPrompt: prompt })
                    });
                    const result = await ragResponse.json();
                    if (result && result.response) {
                        const aiMessageDiv = document.createElement('div');
                        aiMessageDiv.className = 'chat-message ai';
                        aiMessageDiv.textContent = result.response.trim();
                        chatMessages.appendChild(aiMessageDiv);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else {
                        const aiMessageDiv = document.createElement('div');
                        aiMessageDiv.className = 'chat-message ai';
                        aiMessageDiv.textContent = 'Sorry, I could not get a response from the local AI.';
                        chatMessages.appendChild(aiMessageDiv);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                } catch(error) {
                    console.error("Error calling RAG backend:", error);
                    const aiMessageDiv = document.createElement('div');
                    aiMessageDiv.className = 'chat-message ai';
                    aiMessageDiv.textContent = 'Sorry, there was an error connecting to the local AI.';
                    chatMessages.appendChild(aiMessageDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
        }

        // Sidebar menu logic
        const menuToggleButton = document.getElementById('menuToggleButton');
        const sidebarMenu = document.getElementById('sidebarMenu');
        const closeMenuButton = document.getElementById('closeMenuButton');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        let menuOpen = false;
        function openMenu() {
            sidebarMenu.classList.remove('-translate-x-full');
            sidebarMenu.classList.add('translate-x-0');
            sidebarOverlay.classList.remove('opacity-0', 'pointer-events-none');
            sidebarOverlay.classList.add('opacity-100');
            menuOpen = true;
        }
        function closeMenu() {
            sidebarMenu.classList.add('-translate-x-full');
            sidebarMenu.classList.remove('translate-x-0');
            sidebarOverlay.classList.add('opacity-0', 'pointer-events-none');
            sidebarOverlay.classList.remove('opacity-100');
            menuOpen = false;
        }
        function toggleMenu() {
            if (menuOpen) {
                closeMenu();
            } else {
                openMenu();
            }
        }
        menuToggleButton.addEventListener('click', toggleMenu);
        closeMenuButton.addEventListener('click', closeMenu);
        sidebarOverlay.addEventListener('click', closeMenu);
        document.addEventListener('keydown', (e) => {
            if (menuOpen && e.key === 'Escape') closeMenu();
        });

        // Community Feed: Fake comments
        const fakeComments = [
          {
            user: "@surfNJ",
            spot: "Belmar - 16th Ave",
            time: "10 min ago",
            text: "Super fun waist-high sets this morning, glassy and clean! Bring your longboard."
          },
          {
            user: "@wavehunter",
            spot: "Manasquan Inlet",
            time: "30 min ago",
            text: "Wind picked up, a little choppy now but still rideable."
          },
          {
            user: "@kellyfan",
            spot: "Seaside Heights / Casino Pier",
            time: "1 hr ago",
            text: "Caught a couple of nice lefts, crowd was mellow. Water's warming up!"
          },
          {
            user: "@lbi_local",
            spot: "Long Beach Island (LBI)",
            time: "2 hrs ago",
            text: "Tide dropping, waves getting punchier. Watch out for the shorebreak."
          },
          {
            user: "@ocnjgrom",
            spot: "Ocean City",
            time: "3 hrs ago",
            text: "Small but super clean. Perfect for a foamie session."
          }
        ];
        function renderCommunityFeed() {
          const list = document.getElementById('community-comments-list');
          if (!list) return;
          list.innerHTML = fakeComments.map(comment => `
    <li class="bg-white rounded-xl p-4 shadow flex flex-col gap-1 border border-blue-100 text-black text-left">
      <div class="flex items-center gap-2 mb-1">
        <span class="font-semibold text-blue-600">${comment.user}</span>
        <span class="text-xs text-gray-400">${comment.time}</span>
        <span class="ml-auto text-xs text-blue-400 font-semibold">${comment.spot}</span>
      </div>
      <div class="text-black text-base">${comment.text}</div>
    </li>
  `).join('');
        }
    </script>
</body>
</html>